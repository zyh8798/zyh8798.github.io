import{_ as f}from"./ValaxyMain.vue_vue_type_style_index_0_lang.Ba-Rs9WQ.js";import{f as v,a as p}from"./chunks/vue-router.DAeXatbz.js";import{A as m,N as b,a3 as a,U as n,S as l,W as e,u as k,O as g}from"./framework.hhCck54A.js";import"./app.Cd6fqbrk.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/vue-i18n.GNlbZvKN.js";import"./chunks/pinia.DpmgPo9O.js";import"./chunks/@vueuse/motion.C-lzhE44.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.5UdBc-O0.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.B0PJaaz2.js";import"./post.BozAhWpI.js";const y=v("/posts/hello-valaxy",async r=>JSON.parse('{"title":"面试题","description":"","frontmatter":{"title":"面试题","date":"2025-03-10","updated":"2025-03-10","categories":"面试题","tags":["面试题"],"top":1},"headers":[{"level":2,"title":"vue的响应式原理","slug":"vue的响应式原理","link":"#vue的响应式原理","children":[]},{"level":2,"title":"vue2和vue3的区别","slug":"vue2和vue3的区别","link":"#vue2和vue3的区别","children":[]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":2,"title":"VUEX项目的优化手段","slug":"vuex项目的优化手段","link":"#vuex项目的优化手段","children":[]},{"level":2,"title":"promise","slug":"promise","link":"#promise","children":[]},{"level":2,"title":"async await","slug":"async-await","link":"#async-await","children":[]},{"level":2,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":2,"title":"BFC","slug":"bfc","link":"#bfc","children":[]},{"level":2,"title":"如何实现三栏布局","slug":"如何实现三栏布局","link":"#如何实现三栏布局","children":[]},{"level":2,"title":"事件委托","slug":"事件委托","link":"#事件委托","children":[]},{"level":2,"title":"跨域","slug":"跨域","link":"#跨域","children":[]},{"level":2,"title":"ES6","slug":"es6","link":"#es6","children":[]},{"level":2,"title":"数组方法","slug":"数组方法","link":"#数组方法","children":[]},{"level":2,"title":"今日面试题目","slug":"今日面试题目","link":"#今日面试题目","children":[]}],"relativePath":"pages/posts/hello-valaxy.md","lastUpdated":1755165058000}'),{lazy:(r,s)=>r.name===s.name}),z={__name:"hello-valaxy",setup(r,{expose:s}){var d;const{data:o}=y(),u=p(),t=Object.assign(u.meta.frontmatter||{},((d=o.value)==null?void 0:d.frontmatter)||{});return u.meta.frontmatter=t,m("pageData",o.value),m("valaxy:frontmatter",t),globalThis.$frontmatter=t,s({frontmatter:{title:"面试题",date:"2025-03-10",updated:"2025-03-10",categories:"面试题",tags:["面试题"],top:1}}),(i,c)=>{const h=f;return g(),b(h,{frontmatter:k(t)},{"main-content-md":a(()=>c[0]||(c[0]=[l("h2",{id:"vue的响应式原理",tabindex:"-1"},[e("vue的响应式原理 "),l("a",{class:"header-anchor",href:"#vue的响应式原理","aria-label":'Permalink to "vue的响应式原理"'},"​")],-1),l("p",null,[e("vue2的响应式原理就是使用object.defineProprty()来劫持对象属性的getter和setter，当数据变化时，触发setter，通过dep.notify()来通知watcher，watcher通过回调函数来更新视图。"),l("br"),e(" vue3的响应式原理则是使用proxy来劫持对象，当数据变化时，触发handler的set和get方法，通过effect函数来更新视图。")],-1),l("h2",{id:"vue2和vue3的区别",tabindex:"-1"},[e("vue2和vue3的区别 "),l("a",{class:"header-anchor",href:"#vue2和vue3的区别","aria-label":'Permalink to "vue2和vue3的区别"'},"​")],-1),l("p",null,[e("首先在响应式的diff算法上就有区别 vue2的diff算法是双端比较，vue3的diff算法是单端比较，vue3的diff算法性能更好。"),l("br"),e(" 其次在组件的更新上也有区别，vue2的组件更新是异步的，vue3的组件更新是同步的。"),l("br"),e(" 最后在生命周期上也有区别，vue2的生命周期是同步的，vue3的生命周期是异步的。"),l("br"),e(" vue2的写法和vue3的写法也有所不同"),l("br"),e(" vue2的选项式APIvue3是组合式API，vue2的写法是options api，vue3的写法是composition api，vue2的写法是面向对象的，vue3的写法是面向函数的。 VUE3支持TS和tree-shaking vue2不支持")],-1),l("h2",{id:"闭包",tabindex:"-1"},[e("闭包 "),l("a",{class:"header-anchor",href:"#闭包","aria-label":'Permalink to "闭包"'},"​")],-1),l("p",null,"闭包是指有权访问外部函数的变量和参数的函数,闭包的作用是延长变量的生命周期，闭包的缺点是会造成内存泄漏，闭包的解决方法是使用weakMap和weakSet来存储闭包，避免内存泄漏。 可以用来防抖节流什么的",-1),l("h2",{id:"vuex项目的优化手段",tabindex:"-1"},[e("VUEX项目的优化手段 "),l("a",{class:"header-anchor",href:"#vuex项目的优化手段","aria-label":'Permalink to "VUEX项目的优化手段"'},"​")],-1),l("p",null,[e("代码层面:合理使用v-if v-show 防抖节流 合并请求"),l("br"),e(" 路由懒加载 图片格式化,懒加载 suspence组件懒加载(vue3)"),l("br"),e(" keep-alive 合理使用key,computed v-model.lazy 冻结对象(vue2) 打包方面:tree-shaking 代码分割 gzip压缩 cdn引入")],-1),l("h2",{id:"promise",tabindex:"-1"},[e("promise "),l("a",{class:"header-anchor",href:"#promise","aria-label":'Permalink to "promise"'},"​")],-1),l("p",null,"它的出现统一了了异步编码规则",-1),l("h2",{id:"async-await",tabindex:"-1"},[e("async await "),l("a",{class:"header-anchor",href:"#async-await","aria-label":'Permalink to "async await"'},"​")],-1),l("p",null,"async await是promise的语法糖，async函数返回一个promise对象，await等待promise对象的状态改变，如果状态是resolved，则返回promise对象的值，如果状态是rejected，则抛出异常。",-1),l("h2",{id:"事件循环",tabindex:"-1"},[e("事件循环 "),l("a",{class:"header-anchor",href:"#事件循环","aria-label":'Permalink to "事件循环"'},"​")],-1),l("p",null,"事件循环是指浏览器或Node.js在执行代码时，会先执行同步代码，然后执行异步代码，异步代码会放入任务队列中，当同步代码执行完毕后，会从任务队列中取出异步代码执行，这个过程会一直重复，直到任务队列中的异步代码全部执行完毕。宏任务和微任务的区别是，宏任务会在下一个事件循环中执行，微任务会在当前事件循环中执行。",-1),l("h2",{id:"bfc",tabindex:"-1"},[e("BFC "),l("a",{class:"header-anchor",href:"#bfc","aria-label":'Permalink to "BFC"'},"​")],-1),l("p",null,"称之为块级格式化上下文,可以用来布局解决垂直外边距合并问题触发方式为overflow:不为hidden或者auto,浮动元素,绝对定位元素,行内块元素,flex元素,grid元素",-1),l("h2",{id:"如何实现三栏布局",tabindex:"-1"},[e("如何实现三栏布局 "),l("a",{class:"header-anchor",href:"#如何实现三栏布局","aria-label":'Permalink to "如何实现三栏布局"'},"​")],-1),l("ol",null,[l("li",null,"flex布局"),l("li",null,"双飞翼布局"),l("li",null,"圣杯布局"),l("li",null,"绝对定位布局"),l("li",null,"table布局"),l("li",null,"grid布局")],-1),l("h2",{id:"事件委托",tabindex:"-1"},[e("事件委托 "),l("a",{class:"header-anchor",href:"#事件委托","aria-label":'Permalink to "事件委托"'},"​")],-1),l("p",null,"事件委托是指将事件绑定到父元素上，通过事件冒泡机制来触发子元素的事件，事件委托的优点是可以减少事件绑定的次数，提高性能，缺点是事件委托只能处理冒泡阶段的事件，无法处理捕获阶段的事件。",-1),l("h2",{id:"跨域",tabindex:"-1"},[e("跨域 "),l("a",{class:"header-anchor",href:"#跨域","aria-label":'Permalink to "跨域"'},"​")],-1),l("p",null,"跨域是指浏览器出于安全考虑，限制从一个域加载的脚本如何与另一个域的内容进行交互，跨域的解决方法有jsonp、cors、postMessage、nginx代理、webpack代理、websocket等。",-1),l("h2",{id:"es6",tabindex:"-1"},[e("ES6 "),l("a",{class:"header-anchor",href:"#es6","aria-label":'Permalink to "ES6"'},"​")],-1),l("ol",null,[l("li",null,"let const"),l("li",null,"箭头函数"),l("li",null,"模板字符串"),l("li",null,"解构赋值"),l("li",null,"Promise"),l("li",null,"async await"),l("li",null,"class"),l("li",null,"模块化"),l("li",null,"Proxy"),l("li",null,"Reflect"),l("li",null,"Set Map"),l("li",null,"Symbol"),l("li",null,"for of"),l("li",null,"Array.from"),l("li",null,"Array.of")],-1),l("h2",{id:"数组方法",tabindex:"-1"},[e("数组方法 "),l("a",{class:"header-anchor",href:"#数组方法","aria-label":'Permalink to "数组方法"'},"​")],-1),l("ol",null,[l("li",null,"push"),l("li",null,"pop"),l("li",null,"shift"),l("li",null,"unshift"),l("li",null,"slice"),l("li",null,"splice"),l("li",null,"concat"),l("li",null,"join"),l("li",null,"reverse"),l("li",null,"sort"),l("li",null,"forEach"),l("li",null,"map"),l("li",null,"filter"),l("li",null,"reduce"),l("li",null,"reduceRight"),l("li",null,"every"),l("li",null,"some"),l("li",null,"find"),l("li",null,"findIndex"),l("li",null,"fill"),l("li",null,"copyWithin"),l("li",null,"includes"),l("li",null,"flat"),l("li",null,"flatMap"),l("li",null,"entries"),l("li",null,"keys"),l("li",null,"values"),l("li",null,"from"),l("li",null,"of"),l("li",null,"isArray")],-1),l("h2",{id:"今日面试题目",tabindex:"-1"},[e("今日面试题目 "),l("a",{class:"header-anchor",href:"#今日面试题目","aria-label":'Permalink to "今日面试题目"'},"​")],-1),l("p",null,"1.微信小程序自定义tabbar图标闪烁问题 2.函数传参是值传递还是引用传递 3.深拷贝遇到嵌套对象怎么解决 4.虚拟列表的实现原理 5.图片懒加载后反复上下滑动如何判断已经加载过 6.uniapp如何让一个请求百分之百优先于别的请求",-1)])),"main-header":a(()=>[n(i.$slots,"main-header")]),"main-header-after":a(()=>[n(i.$slots,"main-header-after")]),"main-nav":a(()=>[n(i.$slots,"main-nav")]),"main-content-before":a(()=>[n(i.$slots,"main-content-before")]),"main-content":a(()=>[n(i.$slots,"main-content")]),"main-content-after":a(()=>[n(i.$slots,"main-content-after")]),"main-nav-before":a(()=>[n(i.$slots,"main-nav-before")]),"main-nav-after":a(()=>[n(i.$slots,"main-nav-after")]),comment:a(()=>[n(i.$slots,"comment")]),footer:a(()=>[n(i.$slots,"footer")]),aside:a(()=>[n(i.$slots,"aside")]),"aside-custom":a(()=>[n(i.$slots,"aside-custom")]),default:a(()=>[n(i.$slots,"default")]),_:3},8,["frontmatter"])}}};export{z as default,y as usePageData};
